# -*- coding: utf-8 -*-
"""Untitled12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/141KyuBRzMbnlsfNwGwisfnKozZfoQa7q
"""



!pip install rawpy opencv-python numpy

from google.colab import drive

drive.mount('/content/drive')







# Mencantumkan isi dari root MyDrive untuk menemukan folder DJI_Photo
!ls /content/drive/MyDrive/

"""# Task
Compress all DNG files found recursively within the `/content/drive/MyDrive/DJI_Photo` directory to JPEG format with a target size between 1-5MB using OpenCV, preserving the original folder structure in the output.

## Temukan semua file dng secara rekursif

### Subtask:
Telusuri seluruh struktur direktori di dalam `/content/drive/MyDrive/DJI_Photo` dan kumpulkan daftar semua jalur file DNG.

**Reasoning**:
The subtask requires traversing a directory and finding all files with a `.dng` extension. This can be done using `os.walk` and checking the file extension.
"""

import os

root_dir = '/content/drive/MyDrive/DJI_Photo'
dng_files = []

for dirpath, dirnames, filenames in os.walk(root_dir):
    for filename in filenames:
        if filename.lower().endswith('.dng'):
            full_path = os.path.join(dirpath, filename)
            dng_files.append(full_path)

print(f"Found {len(dng_files)} DNG files:")
for dng_file in dng_files:
    print(dng_file)

"""## Siapkan direktori output

### Subtask:
Buat struktur direktori output yang mencerminkan struktur folder sumber di dalam `DJI_Photo`, di mana file JPEG yang dikompresi akan disimpan.

**Reasoning**:
Create the output directory structure mirroring the source directory structure for the compressed JPEG files.
"""

import os

output_root_dir = '/content/compressed_DJI_Photo'

for dng_file in dng_files:
    # Determine the corresponding output path by replacing the source root with the output root
    relative_path = os.path.relpath(dng_file, root_dir)
    output_dir = os.path.join(output_root_dir, os.path.dirname(relative_path))

    # Create the output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)

print(f"Output directory structure created under: {output_root_dir}")

"""## Proses setiap file dng

### Subtask:
Iterasi melalui daftar file DNG yang ditemukan.

**Reasoning**:
Iterate through the list of DNG files as required by the subtask.

## Temukan semua file dng secara rekursif

### Subtask:
Telusuri seluruh struktur direktori di dalam `/content/drive/MyDrive/DJI_Photo` dan kumpulkan daftar semua jalur file DNG.

**Reasoning**:
The subtask requires traversing a directory and finding all files with a `.dng` extension. This can be done using `os.walk` and checking the file extension.
"""

import os

root_dir = '/content/drive/MyDrive/DJI_Photo'
dng_files = []

for dirpath, dirnames, filenames in os.walk(root_dir):
    for filename in filenames:
        if filename.lower().endswith('.dng'):
            full_path = os.path.join(dirpath, filename)
            dng_files.append(full_path)

print(f"Found {len(dng_files)} DNG files:")
# Print only a few examples if the list is very long
for i, dng_file in enumerate(dng_files):
    if i < 10: # Print first 10 files
        print(dng_file)
    elif i == 10:
        print("...")
        break

# You can print all files if needed, but be cautious with very large lists
# for dng_file in dng_files:
#     print(dng_file)

"""## Siapkan direktori output

### Subtask:
Buat struktur direktori output yang mencerminkan struktur folder sumber di dalam `DJI_Photo`, di mana file JPEG yang dikompresi akan disimpan.

**Reasoning**:
Create the output directory structure mirroring the source directory structure for the compressed JPEG files.
"""

import os

root_dir = '/content/drive/MyDrive/DJI_Photo' # Source root directory
output_root_dir = '/content/compressed_DJI_Photo' # Target output directory

# Assuming dng_files list is available from the previous step (cell_id: c7778760)

for dng_file in dng_files:
    # Determine the corresponding output path by replacing the source root with the output root
    relative_path = os.path.relpath(dng_file, root_dir)
    output_dir = os.path.join(output_root_dir, os.path.dirname(relative_path))

    # Create the output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)

print(f"Output directory structure created under: {output_root_dir}")

"""## Proses setiap file dng

### Subtask:
Iterasi melalui daftar file DNG yang ditemukan.

**Reasoning**:
Iterate through the list of DNG files as required by the subtask.
"""

# Cukup dijalankan sekali, Sekarang gunakan file hasil shared yang telah diberikan saja

# import os
# import rawpy
# import cv2
# import numpy as np
# # uses only CPU,
# root_dir = '/content/drive/MyDrive/DJI_Photo' # Source root directory
# output_root_dir = '/content/compressed_DJI_Photo' # Target output directory

# # Assuming dng_files list is available from the first step (cell_id: c7778760)
# if 'dng_files' in locals() and dng_files:
#     print(f"Memulai proses kompresi untuk {len(dng_files)} file DNG...")

#     for dng_path in dng_files:
#         try:
#             # Determine the corresponding output path
#             relative_path = os.path.relpath(dng_path, root_dir)
#             output_jpeg_path = os.path.join(output_root_dir, os.path.splitext(relative_path)[0] + '.jpeg')

#             # Ensure the output directory for this file exists (already done in step 2, but good to be safe)
#             output_dir = os.path.dirname(output_jpeg_path)
#             os.makedirs(output_dir, exist_ok=True)

#             print(f"\nMemproses: {dng_path}")

#             # Read DNG file using rawpy
#             with rawpy.imread(dng_path) as raw:
#                 # Postprocess to get a standard image format (e.g., sRGB)
#                 # Using 16-bit output might provide better quality for compression
#                 rgb_image = raw.postprocess(output_bps=16) # Output in 16-bit per channel

#             # Convert from 16-bit (0-65535) to 8-bit (0-255) if necessary for OpenCV JPEG saving
#             # OpenCV imwrite for JPEG typically expects 8-bit
#             if rgb_image.dtype == np.uint16:
#                  rgb_image = (rgb_image / 256).astype(np.uint8)


#             success = False
#             best_quality = -1
#             # Iterate to find the right quality setting (JPEG quality 0-100)
#             # We can start with a higher quality and decrease, or use a binary search approach
#             # Let's use a simple decreasing loop for demonstration
#             # Start from 90 and go down in steps of 5
#             # A more precise search might be needed for strict 1-5MB
#             initial_quality = 90
#             quality_step = 5
#             min_quality = 10 # Don't go below a certain quality to avoid extreme degradation

#             # Store the quality that gave a size < 1MB if we overshoot
#             last_quality_above_1mb = -1
#             last_size_above_1mb = -1

#             for quality in range(initial_quality, min_quality - 1, -quality_step):
#                 if quality < 0: quality = 0 # Ensure quality is not negative
#                 compression_params = [int(cv2.IMWRITE_JPEG_QUALITY), quality]
#                 cv2.imwrite(output_jpeg_path, cv2.cvtColor(rgb_image, cv2.COLOR_RGB2BGR), compression_params)

#                 # Check file size
#                 file_size_bytes = os.path.getsize(output_jpeg_path)
#                 file_size_mb = file_size_bytes / (1024 * 1024)

#                 # print(f"  Saved with quality {quality}, size: {file_size_mb:.2f} MB") # Optional: print progress for each quality

#                 # Check if the size is within the target range (1-5MB)
#                 if 1 <= file_size_mb <= 5:
#                     print(f"  Target size achieved for {os.path.basename(dng_path)} with quality {quality}, size: {file_size_mb:.2f} MB.")
#                     best_quality = quality
#                     success = True
#                     break # Exit quality loop if target size is met

#                 # If file is still too large, continue to lower quality
#                 if file_size_mb > 5:
#                     continue

#                 # If file is too small (< 1MB)
#                 if file_size_mb < 1:
#                     # The previous quality (quality + quality_step) was either in the range or > 5MB.
#                     # If the previous size was > 5MB and current is < 1MB, the ideal quality is between 'quality' and 'quality + quality_step'.
#                     # We can refine the search here if needed for more precision.
#                     # For simplicity, let's note this and stop decreasing quality significantly.
#                     last_quality_above_1mb = quality + quality_step
#                     last_size_above_1mb = (os.path.getsize(output_jpeg_path.replace('.jpeg', f'_q{last_quality_above_1mb}.jpeg')) / (1024 * 1024)) if os.path.exists(output_jpeg_path.replace('.jpeg', f'_q{last_quality_above_1mb}.jpeg')) else -1 # Try to get size of prev quality if saved

#                     # Optional: Refine search between quality and last_quality_above_1mb
#                     # This would involve a smaller step or binary search in this range.
#                     # For now, we'll stop the main loop if it goes below 1MB
#                     break # Stop decreasing quality significantly if it goes below 1MB


#             if not success:
#                 # If target size was not achieved, report the closest we got or failure
#                 if 0 < file_size_mb < 1:
#                      print(f"  Could not achieve target size (1-5 MB) for {os.path.basename(dng_path)}. Smallest size achieved was {file_size_mb:.2f} MB with quality {quality}.")
#                      # You might want to decide whether to keep this small file or delete it
#                      best_quality = quality # The quality that resulted in <1MB
#                      # Optional: delete the file os.remove(output_jpeg_path)

#                 elif file_size_mb > 5 and quality <= min_quality:
#                      print(f"  Could not achieve target size (1-5 MB) for {os.path.basename(dng_path)}. File size is still {file_size_mb:.2f} MB even at minimum quality {min_quality}.")
#                      best_quality = quality # The quality that resulted in >5MB at min_quality
#                      # Decide whether to keep this large file

#                 else:
#                      print(f"  Could not achieve target size (1-5 MB) for {os.path.basename(dng_path)}. Review process.")
#                      # This case might occur if the loop finishes without breaking (e.g., quality goes below min_quality)
#                      pass # Decide how to handle this case

#             # Clean up intermediate files if a precise search was done and saved intermediate files
#             # (Not implemented in this simple loop)


#         except rawpy.LibRawError as e:
#             print(f"Gagal membaca file DNG {os.path.basename(dng_path)}: {e}")
#         except Exception as e:
#             print(f"Terjadi kesalahan saat memproses file {os.path.basename(dng_path)}: {e}")

#     print("\nProses kompresi untuk semua file DNG selesai.")

# else:
#     print("Tidak ada file DNG yang ditemukan atau daftar dng_files kosong.")

# Cukup dijalankan sekali, Sekarang gunakan file hasil shared yang telah diberikan saja
# import os

# source_dir = '/content/compressed_DJI_Photo'
# destination_dir = '/content/drive/MyDrive/'

# print(f"Menyalin '{source_dir}' ke '{destination_dir}'...")

# # Use the shell command 'cp' for recursive copying
# # -r: recursive copy
# # -v: verbose (optional, shows files being copied)
# !cp -r "{source_dir}" "{destination_dir}"

# print("Proses penyalinan selesai.")
# print(f"File-file JPEG yang dikompresi sekarang tersedia di '{destination_dir}compressed_DJI_Photo' di Google Drive Anda.")

# Mulai Dari sini